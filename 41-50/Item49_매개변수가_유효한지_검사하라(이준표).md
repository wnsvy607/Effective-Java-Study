# Item49 매개변수가 유효한지 검사하라

## 요약
메서드나 생성자를 작성할 때 매개변수의 유효성(null인지, 유효한 값인지)을 메서드 코드 시작 부분에서 검사하고 이러한 제약들을 문서화하자.


## 매개변수 검사
메서드와 생성자는 매개변수 값이 특정 조건을 만족하기를 기대하며 로직을 수행한다.
예를 들어서, 인덱스 값은 음수가 아니며, 객체 참조는 null이 아니어야 하는 것 등이 있다.
이런 제약들은 **반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사**해야 한다.
이는 "오류는 가능한 한 빨리 (발생한 곳에서) 잡아야 한다"는 일반 원칙의 한 사례이기도 하다.
**오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.**


## 매개변수 검사를 제대로 하지 않을 때 발생하는 문제
매개변수 검사를 하지 않을 경우 다음과 같은 문제가 발생할 수 있다.
1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. 메서드는 잘 수행되지만 잘못된 결과를 반환한다.
3. 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어 놓아서 미래의 알 수 없는 시점에 이메서드와는 관련 없는 오류를 낸다. 즉, 실패 원자성(아이템 76)을 어기는 결과를 낳을 수 있다.


## public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.
먼저 예시를 보고 파악해보자
```java
/**
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
 *
 * @param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0)
        throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
    ... // 계산 수행
}
```
- 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다. -> API 사용자가 제약을 지킬 가능성을 크게 높일 수 있다.
- 이 메서드는 m이 null이면 `m.signum()` 호출 때 `NullPointerException`을 던진다. 그런데 메서드 수준이 아니라 BigInteger 클래스 수준에서 해당 예외가 기술되어 있다. 클래스 수준의 주석은 그 클래스의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.
- `@Nullable`이나 이와 비슷한 애너테이션을 사용해 특정 매개변수는 null이 될 수 있다고 알려줄 수도 있지만, **표준적인 방법은 아니다**.
- Java 7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.
  - 원하는 예외와 메시지도 지정할 수 있다.
  - 또한 입력을 그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행할 수 있다.(반환 값을 사용하지 않고 null검사 용도로만 사용해도 된다.)
  - Java 9에서는 Objects에 범위 검사 기능도 더해졌다. `checkFromIndexSize`, `checkFromToIndex`, `checkIndex`라는 메서드들인데, null 검사 메서드만큼 유연하지는 않다. 예외 메시지를 저장할 수 없고, 리스트와 배열 전용으로 설계됐다. 또한 닫힌 범위(closed range; 양 끝단을 포함하는)는 다루지 못한다. 그래도 유용하게 쓰일 수 있다.



## public이 아닌 메서드라면 단언문(assert)를 사용해 매개변수 유효성을 검증할 수 있다.
이것도 먼저 예시를 보자
```java
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    ... // 계산 수행
}
```
- 공개되지 않은 메서드라면 패키지 제작자인 여러분이 메서드가 호출되는 상황을 통제할 수 있다. 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 여러분이 보증할 수 있고, 그렇게 해야 한다.
- 핵심은 단언문들이 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다.


### 단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다. 
1. 실패하면 `AssertionError`를 던진다.
2. 런타임에 아무런 효과도, 성능 저하도 없다.



## 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
- `List`의 경우 배열을 입력 받아 `Objects.requireNonNull`으로 null 검사를 수행한다.
  - 만약 이 검사를 생략한다면 클라이언트가 돌려 받은 `List`를 사용하려 할 때 비로소 `NullPointerException`이 발생한다.
  - 이때가 되면 이 `List`를 어디서 가져왔는지 추적하기 어려워 디버깅이 상당히 괴로워질 수 있다.
- 생성자는 해당 원칙의 특수한 사례다. 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.



## 매개변수 유효성 검사의 예외
다음과 같은 경우에 유효성 검사를 생략할 수 있다.
1. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때
2. 계산 과정에서 암묵적으로 검사가 수행될 때
예를 들어 `Collections.sort(List)`처럼 객체 리스트를 정렬하는 메서드를 생각해보자. 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며, 정렬 과정에서 이 비교가 이뤄진다. 만약 상호 비교될 수 있어야 하며, 정렬 과정에서 이 비교가 이뤄진다. 만약 상호 비교될 수 없는 타입의 객체가 들어 있다면 그 객체와 비교할 때 ClassCastException을 던질 것이다. 따라서 비교하기 앞서 리스트 안의 모든 객체가 상호 비교될 수 있는지 검사해봐야 별다른 실익이 없다. **하지만 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성(아이템 76)을 해칠 수 있으니 주의**하자.

## 잘못된 예외
때로는 계산 과정에서 필요한 유효성 검사가 이뤄지지만 실패했을 때 잘못된 예외를 던지기도 한다. 달리 말하면, 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다는 뜻이다. 이런 경우에는 **아이템 73에서 설명하는 예외 번역(exception translate) 관용구를 사용하여 API 문서에 기재된 예외로 번역해줘야 한다.**


## 오해
**이번 아이템을 "매개변수에 제약을 두는게 좋다"고 해석해서는 안 된다.** 사싦은 그 반대다. 메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건네 받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수록 좋다. 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 드물지 않다.